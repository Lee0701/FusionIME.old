package io.github.lee0701.inputmethod.fusion

import android.content.Context
import android.content.SharedPreferences
import android.content.res.Configuration
import android.preference.PreferenceManager
import com.google.common.base.Optional
import org.mozc.android.inputmethod.japanese.ConfigUtil
import org.mozc.android.inputmethod.japanese.KeycodeConverter
import org.mozc.android.inputmethod.japanese.MozcUtil
import org.mozc.android.inputmethod.japanese.PrimaryKeyCodeConverter
import org.mozc.android.inputmethod.japanese.keyboard.Keyboard
import org.mozc.android.inputmethod.japanese.model.SelectionTracker
import org.mozc.android.inputmethod.japanese.protobuf.ProtoCommands
import org.mozc.android.inputmethod.japanese.session.SessionExecutor
import org.mozc.android.inputmethod.japanese.session.SessionHandlerFactory
import org.mozc.android.inputmethod.japanese.session.SessionExecutor.EvaluationCallback

class MozcInputHandler(
    private val context: Context,
    override val listener: InputHandler.Listener
): InputHandler {

    private val primaryKeyCodeConverter: PrimaryKeyCodeConverter = PrimaryKeyCodeConverter(context)
    private val sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context)
    private val sessionExecutor: SessionExecutor =
        SessionExecutor.getInstanceInitializedIfNecessary(
            SessionHandlerFactory(Optional.of(sharedPreferences)),
            context
        )
    private val selectionTracker: SelectionTracker = SelectionTracker()

    private val renderResultCallback: EvaluationCallback = EvaluationCallback { cmd, event ->
        val command = cmd.orNull() ?: return@EvaluationCallback
        val keyEvent = event.orNull() ?: return@EvaluationCallback
        if (command.input.command.type != ProtoCommands.SessionCommand.CommandType.EXPAND_SUGGESTION) {
            val result = MozcInputResultRenderInputConnection(command, keyEvent, selectionTracker)
            listener.onResult(result)
        }
    }

    private val sendKeyToApplicationCallback: EvaluationCallback = EvaluationCallback { cmd, event ->
        val keyEvent = event.orNull() ?: return@EvaluationCallback
        val result = MozcInputResultInteractIME(keyEvent)
        listener.onResult(result)
    }

    private var currentKeyboardSpecification: Keyboard.KeyboardSpecification? = Keyboard.KeyboardSpecification.QWERTY_KANA

    override fun onKeyEvent(fusionKeyEvent: FusionKeyEvent) {
        val keyEvent = if(fusionKeyEvent is MozcKeyEvent) fusionKeyEvent.keyEvent else null
        val mozcKeyEvent = if(fusionKeyEvent is MozcKeyEvent) fusionKeyEvent.mozcKeyEvent else null
        val keyboardSpecification = if(fusionKeyEvent is MozcKeyEvent) fusionKeyEvent.keyboardSpecification else null
        val touchEventList = if(fusionKeyEvent is MozcKeyEvent) fusionKeyEvent.touchEventList else null

        if (mozcKeyEvent == null && keyboardSpecification == null) {
            // We don't send a key event to Mozc native layer since {@code mozcKeyEvent} is null, and we
            // don't need to update the keyboard specification since {@code keyboardSpecification} is
            // also null.
            // Send a key event (which is generated by Mozc in the usual case) to application.
            sessionExecutor.sendKeyEvent(keyEvent, sendKeyToApplicationCallback)
            return
        }
        sendKeyWithKeyboardSpecification(
            mozcKeyEvent, keyEvent,
            keyboardSpecification, context.resources.configuration,
            touchEventList
        )
    }

    override fun onConversionCandidateSelected(candidateId: Int, rowIndex: Int?) {
    }

    override fun setPreferences(sharedPreferences: SharedPreferences) {
        sessionExecutor.config = ConfigUtil.toConfig(sharedPreferences)
    }

    private fun sendKeyWithKeyboardSpecification(
        mozcKeyEvent: ProtoCommands.KeyEvent?, event: KeycodeConverter.KeyEventInterface?,
        keyboardSpecification: Keyboard.KeyboardSpecification?, configuration: Configuration,
        touchEventList: List<ProtoCommands.Input.TouchEvent>?
    ) {
        val currentKeyboardSpecification = currentKeyboardSpecification
        if (keyboardSpecification != null && currentKeyboardSpecification != null
            && currentKeyboardSpecification != keyboardSpecification) {
            // Submit composition on the transition from software KB to hardware KB by key event.
            // This is done only when mozcKeyEvent is non-null (== the key event is a printable
            // character) in order to avoid clearing pre-selected characters by meta keys.
            if (!currentKeyboardSpecification.isHardwareKeyboard
                && keyboardSpecification.isHardwareKeyboard
                && mozcKeyEvent != null
            ) {
                sessionExecutor.submit(renderResultCallback)
            }
            changeKeyboardSpecificationAndSendKey(
                mozcKeyEvent, event, keyboardSpecification, configuration, touchEventList
            )
            //TODO: Implement this
//            updateStatusIcon()
        } else if (mozcKeyEvent != null) {
            // Send mozcKeyEvent as usual.
            sessionExecutor.sendKey(mozcKeyEvent, event, touchEventList, renderResultCallback)
        } else if (event != null) {
            // Send event back to the application to handle key events which cannot be converted into Mozc
            // key event (e.g. Shift) correctly.
            sessionExecutor.sendKeyEvent(event, sendKeyToApplicationCallback)
        }
    }

    /**
     * Sends Request for changing keyboard setting to mozc server and sends key.
     */
    private fun changeKeyboardSpecificationAndSendKey(
        mozcKeyEvent: ProtoCommands.KeyEvent?, event: KeycodeConverter.KeyEventInterface?,
        keyboardSpecification: Keyboard.KeyboardSpecification, configuration: Configuration,
        touchEventList: List<ProtoCommands.Input.TouchEvent>?
    ) {
        // Send Request to change composition table.
        sessionExecutor.updateRequest(
            MozcUtil.getRequestBuilder(context.resources, keyboardSpecification, configuration).build(),
            touchEventList
        )
        if (mozcKeyEvent == null) {
            // Change composition mode.
            sessionExecutor.switchInputMode(
                Optional.fromNullable(event), keyboardSpecification.compositionMode,
                renderResultCallback
            )
        } else {
            // Send key with composition mode change.
            sessionExecutor.sendKey(
                ProtoCommands.KeyEvent.newBuilder(mozcKeyEvent)
                    .setMode(keyboardSpecification.compositionMode).build(),
                event, touchEventList, renderResultCallback
            )
        }
        currentKeyboardSpecification = keyboardSpecification
    }

}